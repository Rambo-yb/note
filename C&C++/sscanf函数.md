`int sscanf (const char *str,const char * format,........);`
sscanf()会将参数str的字符串根据参数format字符串来转换并格式化数据。转换后的结果存于对应的参数内。
成功返回参数数目，失败返回-1，错误原因存于errno中。
format可以是一个或多个 {%\[\*\] \[width\] \[{h | l | I64 | L}\]type | ' ' | '\\t' | '\\n' | 非%符号}
1.  \* 亦可用于格式中, (即 %\*d 和 %\*s) 加了星号 (\*) 表示跳过此数据不读入. (也就是不把此数据读入参数中)
2. {a|b|c}表示a,b,c中选一，\[d\],表示可以有d也可以没有d。
3. width表示读取宽度。
4. {h | l | I64 | L}:参数的size,通常h表示单字节size，I表示2字节 size,L表示4字节size(double例外),l64表示8字节size。
5. type :见类型说明。
6. 特别的：%\*\[width\] \[{h | l | I64 | L}\]type 表示满足该条件的被过滤掉，不会向目标参数中写入值

类型说明：
c : 单个字符，读取下一个字符。d : 十进制整数，数字前的'+'或'-'可选
e, E, f, g, G : 浮点数：包含了一个小数点、一个可选的前置符号 + 或 -、一个可选的后置字符 e 或 E，以及一个十进制数字
o : 八进制整数
s : 字符串。读取连续字符，直到遇到一个空格字符（空格字符可以是空白、换行和制表符）
u : 无符号十进制整数
x,X : 十六进制整数

支持集合操作：
　　%\[a-z\] 表示匹配a到z中任意字符，贪婪性(尽可能多的匹配)
　　%\[aB'\] 匹配a、B、'中一员，贪婪性
　　%\[^a\] 匹配非a的任意字符，贪婪性
注意：在读入的字符串是空字符串时，sscanf函数并不改变待读入到的字符串的值。

常见用法：
1. 常见用法
```c
char buf[512] = {0};
sscanf("123456 ", "%s", buf);
printf("%s\n", buf);
// 结果为：123456
```

2. 取指定长度的字符串。如在下例中，取最大长度为4字节的字符串
```c
sscanf("123456 ", "%4s", buf);
printf("%s\n", buf);
// 结果为：1234
```

3. 取到指定字符为止的字符串。如在下例中，取遇到空格为止字符串
```c
sscanf("123456 abcdedf", "%[^ ]", buf);
printf("%s\n", buf);
// 结果为：123456
```

4. 取仅包含指定字符集的字符串。如在下例中，取仅包含1到9和小写字母的字符串
```c
sscanf("123456abcdedfBCDEF", "%[1-9a-z]", buf);
printf("%s\n", buf);
// 结果为：123456abcdedf
```

5. 取到指定字符集为止的字符串。如在下例中，取遇到大写字母为止的字符串
```c
sscanf("123456abcdedfBCDEF", "%[^A-Z]", buf);
printf("%s\n", buf);
// 结果为：123456abcdedf
```

6. 给定一个字符串iios/12DDWDFF@122，获取 / 和 @ 之间的字符串，先将"iios/"过滤掉，再将非'@'的一串内容送到buf中
```c
sscanf("iios/12DDWDFF@122", "%*[^\]/%[^@]", buf);
printf("%s\n", buf);
// 结果为：12DDWDFF
```

7. 给定一个字符串““hello, world”，仅保留world。（注意：“，”之后有一空格）
```c
sscanf(“hello, world”, "%*s%s", buf);
printf("%s\n", buf);
// 结果为：world
```
%\*s表示第一个匹配到的%s被过滤掉，即hello被过滤了
如果没有空格则结果为NULL。

sscanf的功能很类似于正则表达式,但却没有正则表达式强大,所以如果对于比较复杂的字符串处理,建议使用正则表达式.